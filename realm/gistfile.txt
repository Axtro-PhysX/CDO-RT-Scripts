```
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"time"

	"realm.pub/tavern/cli/auth"
)

type TagProfile struct {
	Name    string `json:"name"`
	Kind    string `json:"kind"`
	IPRegex string `json:"ip_regex"`
}

var tagProfiles = []TagProfile{
	{
		Name:    "quasarquiet",
		Kind:    "service",
		IPRegex: "^192\\.168\\.[0-9]{1,2}\\.4$",
	},
	{
		Name:    "Desktop",
		Kind:    "service",
		IPRegex: "^172\\.16\\.[0-7]{1,2}\\.5$",
	},
	{
		Name:    "MySQL",
		Kind:    "service",
		IPRegex: "^172\\.16\\.[0-7]{1,2}\\.6$",
	},
	{
		Name:    "FTP",
		Kind:    "service",
		IPRegex: "^172\\.16\\.[0-7]{1,2}\\.7$",
	},
	{
		Name:    "Docker",
		Kind:    "service",
		IPRegex: "^172\\.16\\.[0-7]{1,2}\\.8$",
	},
	{
		Name:    "web",
		Kind:    "service",
		IPRegex: "^172\\.16\\.[0-7]{1,2}\\.9$",
	},
	{
		Name:    "AD",
		Kind:    "service",
		IPRegex: "^172\\.16\\.[0-7]{1,2}\\.10$",
	},
	{
		Name:    "Windows_Desktop",
		Kind:    "service",
		IPRegex: "^172\\.16\\.[0-7]{1,2}\\.11$",
	},
	{
		Name:    "team 0",
		Kind:    "group",
		IPRegex: "^172\\.16\\.0\\.[0-9]{1,3}$",
	},
	{
		Name:    "team 1",
		Kind:    "group",
		IPRegex: "^172\\.16\\.1\\.[0-9]{1,3}$",
	},
	{
		Name:    "team 2",
		Kind:    "group",
		IPRegex: "^172\\.16\\.2\\.[0-9]{1,3}$",
	},
	{
		Name:    "team 3",
		Kind:    "group",
		IPRegex: "^172\\.16\\.3\\.[0-9]{1,3}$",
	},
	{
		Name:    "team 4",
		Kind:    "group",
		IPRegex: "^172\\.16\\.4\\.[0-9]{1,3}$",
	},
	{
		Name:    "team 5",
		Kind:    "group",
		IPRegex: "^172\\.16\\.5\\.[0-9]{1,3}$",
	},
	{
		Name:    "team 6",
		Kind:    "group",
		IPRegex: "^172\\.16\\.6\\.[0-9]{1,3}$",
	},
	{
		Name:    "team 7",
		Kind:    "group",
		IPRegex: "^172\\.16\\.7\\.[0-9]{1,3}$",
	},
}

/*
 * CODE
 */

// Request represents an outgoing GraphQL request
type Request struct {
	Query         string         `json:"query"`
	Variables     map[string]any `json:"variables,omitempty"`
	OperationName string         `json:"operationName,omitempty"`
	Extensions    map[string]any `json:"extensions,omitempty"`
}

// Response is a GraphQL layer response from a handler.
type Response struct {
	Errors []struct {
		Message string `json:"message"`
	} `json:"errors"`
	Extensions map[string]any
}

func (resp Response) Error() string {
	msg := ""
	for _, err := range resp.Errors {
		msg = fmt.Sprintf("%s\n%s;", msg, err.Message)
	}
	return msg
}

func ConvertID(idStr string) int {
	id, err := strconv.Atoi(idStr)
	if err != nil {
		panic(err)
	}
	return id
}

type Host struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	PrimaryIP string `json:"primaryIP"`
}

type Tag struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type Client struct {
	Credential auth.Token
	URL        string
	HTTP       *http.Client
}

func (client *Client) AddHostsToTag(tag Tag, hosts ...Host) error {
	var ids []int
	for _, host := range hosts {
		ids = append(ids, ConvertID(host.ID))
	}

	req := Request{
		OperationName: "addHostsToTag",
		Query: `mutation addHostsToTag($tagID: ID!, $hostIDs: [ID!]!) {
			updateTag(tagID: $tagID, input:{addHostIDs:$hostIDs})  {
				id
		  }
		}`,
		Variables: map[string]any{
			"tagID":   tag.ID,
			"hostIDs": ids,
		},
	}

	var resp Response
	if err := client.do(req, &resp); err != nil {
		return err
	}

	if resp.Errors != nil {
		return fmt.Errorf("graphql error: %s", resp.Error())
	}

	return nil
}

func (client *Client) GetTags() ([]Tag, error) {
	req := Request{
		OperationName: "getTags",
		Query: `query getTags{
			tags {
				id
				name
			}
		}`,
	}
	type GetTagsResponse struct {
		Response
		Data struct {
			Tags []Tag `json:"tags"`
		} `json:"data"`
	}

	var resp GetTagsResponse
	if err := client.do(req, &resp); err != nil {
		return nil, err
	}

	if resp.Errors != nil {
		return nil, fmt.Errorf("graphql error: %s", resp.Error())
	}

	return resp.Data.Tags, nil
}

func (client *Client) CreateTag(name, kind string) (Tag, error) {
	req := Request{
		OperationName: "createTag",
		Query: fmt.Sprintf(`mutation createTag{
			createTag(input:{name:%q, kind:%s}) {
				id
				name
			}
		}`, name, kind),
	}
	type CreateTagResponse struct {
		Response
		Data struct {
			Tag Tag `json:"createTag"`
		} `json:"data"`
	}

	var resp CreateTagResponse
	if err := client.do(req, &resp); err != nil {
		return Tag{}, err
	}

	if resp.Errors != nil {
		return Tag{}, fmt.Errorf("graphql error: %s", resp.Error())
	}

	return resp.Data.Tag, nil
}

func (client *Client) GetHosts() ([]Host, error) {
	req := Request{
		OperationName: "getHosts",
		Query: `query getHosts {
			hosts {
				id
				primaryIP
				name
			}
		}`,
	}

	type GetHostsResponse struct {
		Response
		Data struct {
			Hosts []Host `json:"hosts"`
		} `json:"data"`
	}
	var resp GetHostsResponse
	if err := client.do(req, &resp); err != nil {
		return nil, fmt.Errorf("http request failed: %w", err)
	}

	if resp.Errors != nil {
		return nil, fmt.Errorf("graphql error: %s", resp.Error())
	}

	return resp.Data.Hosts, nil
}

// do sends a GraphQL request and returns the response
func (client *Client) do(gqlReq Request, gqlResp any) error {

	data, err := json.Marshal(gqlReq)
	if err != nil {
		return fmt.Errorf("failed to marshal json request to json: %w", err)
	}

	req, err := http.NewRequest(http.MethodPost, client.URL, bytes.NewBuffer(data))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	client.Credential.Authenticate(req)

	resp, err := client.HTTP.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %v", err)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if err := json.Unmarshal(body, gqlResp); err != nil {
		return fmt.Errorf("failed to unmarshal body to json: %v", err)
	}

	return nil
}

func getAuthToken(ctx context.Context, tavernURL, cachePath string) (auth.Token, error) {
	tokenData, err := os.ReadFile(cachePath)
	if os.IsNotExist(err) {
		token, err := auth.Authenticate(ctx, auth.BrowserFunc(func(url string) error { log.Printf("OPEN THIS: %s", url); return nil }), tavernURL)

		// token, err := auth.Authenticate(ctx, auth.BrowserFunc(browser.OpenURL), tavernURL)
		if err != nil {
			return auth.Token(""), err
		}
		if err := os.WriteFile(cachePath, []byte(token), 0640); err != nil {
			log.Printf("[WARN] Failed to save token to credential cache (%q): %v", cachePath, err)
		}
		return token, nil
	}
	if err != nil {
		return auth.Token(""), fmt.Errorf("failed to read credential cache (%q): %v", cachePath, err)
	}

	log.Printf("Loaded authentication credentials from %q", cachePath)
	return auth.Token(tokenData), nil
}

func NewPrimaryIPHostsFilter(re string) func([]Host) (matching []Host) {
	regex := regexp.MustCompile(re)
	return func(hosts []Host) (matching []Host) {
		// Find Matching Hosts
		for _, host := range hosts {
			if regex.Match([]byte(host.PrimaryIP)) {
				matching = append(matching, host)
			}
		}
		return
	}
}

func NewHostnameHostsFilter(re string) func([]Host) (matching []Host) {
	regex := regexp.MustCompile(re)
	return func(hosts []Host) (matching []Host) {
		// Find Matching Hosts
		for _, host := range hosts {
			if regex.Match([]byte(host.Name)) {
				matching = append(matching, host)
			}
		}
		return
	}
}

func UpsertTagForHosts(client *Client, name string, kind string, hostFilter func([]Host) []Host) error {
	// List Hosts
	hosts, err := client.GetHosts()
	if err != nil {
		return err
	}

	// Filter Hosts
	hosts = hostFilter(hosts)

	// List Tags
	tags, err := client.GetTags()
	if err != nil {
		return err
	}

	// Check if this one already exists
	var targetTag *Tag
	for _, tag := range tags {
		if tag.Name == name {
			log.Printf("tag %q already exists, skipping creation", tag.Name)
			targetTag = &tag
			break
		}
	}

	// Create Tag (if it does not exist)
	if targetTag == nil {
		t, err := client.CreateTag(name, kind)
		if err != nil {
			return err
		}
		targetTag = &t
	}

	// Apply Tag to Hosts
	return client.AddHostsToTag(*targetTag, hosts...)
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	var (
		tavernURL      = "https://tavern.aws-metadata.com"
		credentialPath = ".tavern-auth"
	)

	token, err := getAuthToken(ctx, tavernURL, credentialPath)
	if err != nil {
		log.Fatalf("failed to obtain authentication credentials: %v", err)
	}

	client := &Client{
		Credential: token,
		URL:        fmt.Sprintf("%s/graphql", tavernURL),
		HTTP: &http.Client{
			Timeout: 60 * time.Second,
		},
	}

	hosts, err := client.GetHosts()
	if err != nil {
		log.Fatalf("failed to query hosts: %v", err)
	}

	log.Printf("Successfully queried hosts (len=%d)", len(hosts))
	for _, host := range hosts {
		log.Printf("Found Host: id=%s\tname=%s\tip=%s", host.ID, host.Name, host.PrimaryIP)

	}

	for _, profile := range tagProfiles {
		if profile.IPRegex != "" {
			log.Printf("[INFO] Creating %q", profile.Name)
			if err := UpsertTagForHosts(client, profile.Name, profile.Kind, NewPrimaryIPHostsFilter(profile.IPRegex)); err != nil {
				log.Printf("[ERROR] Failed to create %q: %v", profile.Name, err)
			}
		}
	}
}
```
